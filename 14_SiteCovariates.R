#################################################################################        
# Build a dataframe from scratch for the yearly site covariates by plugging in 
#    data extracted from GIS layers or generated by hand for Location.
#################################################################################

# FORMAT SITE COVARIATES ########################################################
# 
# These are the variables that vary between sites, but not between years. They 
#    also don't vary between surveys.
# 
### CREEK ###
     
     # generate vector of creeks
     creek_m <- matrix(rep(c("AC","CH","EP","LT"), each = 15))
     
     # name the rows and column
     rownames(creek_m) <- l_p
     colnames(creek_m) <- "Creek"
   
### ELEVATION ### 
     
     # read in data
     elev <- read.csv("prep_data/Elevation.csv")
     
     # keep only the entries that I need for AC, CH, EP, LT & the elevation values
     elev_sub <- matrix(elev[1:60,8], ncol = 1)
     
     
     # scale the values, so they have mean 0 and SD of 1 because that data is 
     #    continuous
     elev_scaled <- scale(elev_sub)
     
     # that's the final matrix too because it was pre-formatted mostly 
     elev_m <- matrix(elev_scaled)
     
     # names the rows to keep track of them
     rownames(elev_m) <- elev$Site[1:60]
     colnames(elev_m) <- "Elevation"
     
     # clean up
     rm(elev, elev_sub, elev_scaled)

     
### Green Vegetation ### 
     
     # read in data
     green <- read.csv("prep_data/green_veg_per_point.csv")
     
     # scale the values, so they have mean 0 and SD of 1 because that data is 
     #    continuous
     green_scaled <- scale(green$AREA)
     
     # that's the final matrix too because it was pre-formatted mostly 
     green_m <- matrix(green_scaled)
     
     # names the rows to keep track of them
     rownames(green_m) <- green$ID[1:60]
     colnames(green_m) <- "Green_Veg"
     
     # clean up
     rm(green, green_scaled)

### ASPECT ### - Random numbers

aspect

### WATERSHED SIZE ### - Random numbers

watershed

### STREAM ORDER ### - Random numbers

stream_order

### VEGETATION VARIABLES ### - Random numbers
### 
### NEED TO FILL IN WITH ACTUAL DATA LATER ###
### All numbers are -2 to 2 as if they've been scaled, which I'll need to do

# set psuedo-random point of reference so values are reproducable later
set.seed(23)

veg_oak
veg_woody 
veg_shurb 
veg_grass
veg_canopy
veg_width

### MERGE ###

# make it a dataframe
first_occup_covar <- as.data.frame(cbind(creek_m, elev_m, green_m))

# get the continuous variables into the dataframe as numeric data becuase it's 
#    been getting read in a factors. The as.numeric() function has been taking
#    the factor level numbers and using those, so going to characters first was 
#    needed, so then the numbers as character would be turned into numeric values.
first_occup_covar$Elevation <- as.numeric(as.character(first_occup_covar$Elevation))
first_occup_covar$Green_Veg <- as.numeric(as.character(first_occup_covar$Green_Veg))
#first_occup_covar$Slope_Mean <- as.numeric(as.character(first_occup_covar$Slope_Mean))


# the numeric data is being read as factors, so back to numbers
# first_occup_df[2:11] <- apply(first_occup_df[,2:11], MARGIN = 2, as.numeric)
     # apply() applies a function, so follow me for a bit
          # first is the data, I'm telling it just to look at columns 2 through 11
          #    because that's my numeric data
          # MARGIN tells apply() how to apply the function: 1 is on rows, 2 is columns
          # next is the function, so I picked as.numeric() because I want to go
          #    from factors to numbers. Notice the () isn't necessary to include.
          #    In fact, I can't include the () because that'll mess with it

labels <- c("loc", "elev", "slope", "aspect", "watershed", "veg_oak", 
            "veg_woody", "veg_shurb", "veg_grass", "veg_canopy", "veg_width")

col_labels <-paste0("FO_",labels)

colnames(first_occup_df) <- col_labels

str(first_occup_df)
View(first_occup_df)

# clean up
rm("loc", "elev", "slope", "aspect", "watershed", "veg_oak", 
   "veg_woody", "veg_shurb", "veg_grass", "veg_canopy", "veg_width")
rm("col_labels","round_data","num_data")
rm("first_occup")

# END SITE COVARIATES ###########################################################

# REMOVED VARIABLES #############################################################
### SLOPE ###
     # # read in data
     # slope <- read.csv("prep_data/Slope.csv")
     # 
     # # keep only the entries that I need for AC, CH, EP, LT & the elevation values
     # # start with just using the mean slope value
     # slope_sub <- matrix(slope[1:60,8], ncol = 1)
     # 
     # 
     # # scale the values, so they have mean 0 and SD of 1 because that data is 
     # #    continuous
     # slope_scaled <- scale(slope_sub)
     # 
     # # that's the final matrix too because it was pre-formatted mostly 
     # slope_m <- matrix(slope_scaled)
     # 
     # # names the rows to keep track of them
     # rownames(slope_m) <- slope$Site[1:60]
     # colnames(slope_m) <- "Slope_Mean"
     # 
     # # clean up
     # rm(slope, slope_sub, slope_scaled)

### Look at corrlations ##############################################################
### http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software

library(Hmisc) # the Hmisc package let's me calculate the t- and p-values

res <- rcorr(as.matrix(first_occup_df[2:11]))
     # the data has to be in a matrix to use the rcorr() function, dfs are no good

# Extract the correlation coefficients
res$r
# Extract p-values
res$P

# got function from on line
# ++++++++++++++++++++++++++++
# flattenCorrMatrix
# ++++++++++++++++++++++++++++
# cormat : matrix of the correlation coefficients
# pmat : matrix of the correlation p-values
flattenCorrMatrix <- function(cormat, pmat) {
     ut <- upper.tri(cormat)
     data.frame(
          row = rownames(cormat)[row(cormat)[ut]],
          column = rownames(cormat)[col(cormat)[ut]],
          cor  =(cormat)[ut],
          p = pmat[ut]
     )
}

flattenCorrMatrix(res$r, res$P)


library(corrplot) # the corrplot package lets me visual the correlations

corrplot(res$r, type = "lower", order = "hclust", 
         tl.col = "black", tl.srt = 90)


library(PerformanceAnalytics)
chart.Correlation(first_occup_df[2:11], histogram=TRUE, pch=19)
     # dataframes are fine for this one

# Test if Greenness and elevation are related
     elev_green <- lm(data = first_occup_covar, Elevation ~ Green_Veg)
     summary(elev_green)
     plot(first_occup_covar$Elevation, first_occup_covar$Green_Veg)

# test if creek and vegetatio are related
     # Compute the analysis of variance
     creek_green.aov <- aov(Green_Veg ~ Creek, data = first_occup_covar)
     # Summary of the analysis
     summary(creek_green.aov)
     # visualize the relationship
     plot(first_occup_covar$Creek, first_occup_covar$Green_Veg)
     
# test if creek and elevation are related
     # Compute the analysis of variance
     creek_elev.aov <- aov(Elevation ~ Creek, data = first_occup_covar)
     # Summary of the analysis
     summary(creek_elev.aov)
     # visualize the relationship
     plot(first_occup_covar$Creek, first_occup_covar$Elevation)
     
# Test if them all
     green_both <- lm(data = first_occup_covar, Creek ~ Elevation + Green_Veg)
     summary(green_both)
     
     